// provides a translator to read hex/int values from strings in Boost property trees
// code adopted from https://stackoverflow.com/a/9754025

#ifndef CADIDAQ_caenEnumTranslator_hpp
#define CADIDAQ_caenEnumTranslator_hpp

#include <boost/property_tree/ptree.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/predicate.hpp> // boost::starts_with
#include <boost/lexical_cast.hpp>

#include <CaenEnum2str.hpp> // generated by CMake in build directory
#include <helper.hpp>       // helper functions

/// Custom translator for CAEN enums (only supports std::string as internal type)
template<typename T>
struct caenEnumTranslator
{
  typedef std::string internal_type;
  typedef T           external_type;

    // Converts a (hex)string to int
  boost::optional<external_type> get_value(const internal_type& str){
        if (!str.empty()){
          external_type value;
          // get a converter for this CAEN enum type
          cadidaq::CaenEnum2str enumConverter;
          auto* map = enumConverter.getBimap(value);
          // add the leading part of the CAEN enum ("CAEN_DGTZ_"...)
          std::string searchstr = findEnumRoot(*map) + str;

          // case-insensitive search for string in bimap matching search string
          typedef typename boost::bimap< std::string, external_type >::left_const_iterator const_iterator;
          for( const_iterator i = map->left.begin(), iend = map->left.end(); i != iend; ++i ){
            if(boost::iequals(boost::algorithm::to_lower_copy(i->first), searchstr)){
              return boost::optional<external_type>(i->second);
            }
          }
          // could not find value in bimap, could be integer value instead
          try{
            value = static_cast<external_type>( boost::lexical_cast<int>(str) );
          }
          catch(boost::bad_lexical_cast &){
              // if it throws, it's not a number either
              return boost::optional<external_type>(boost::none);
          }
          // return the converted result
          return boost::optional<external_type>(value);
        }
        else
          return boost::optional<external_type>(boost::none);
    }

  // Converts a CAEN enum to string
  boost::optional<internal_type> put_value(const external_type& value){
    // get a converter for this CAEN enum type
    cadidaq::CaenEnum2str enumConverter;
    auto* map = enumConverter.getBimap(value);
    std::string str;
    // find the string corresponding to the setting's enum value in the bimap
    try{
      str = map->right.at(value);
      // remove the first part originating from CAEN's enum naming convention ("CAEN_DGTZ_".....)
      str.erase(0,findEnumRoot(*map).length());
    }
    catch (std::out_of_range & e){
      // return just the integer should the conversion have failed
      return boost::optional<internal_type>(std::to_string(value));
    }
    return boost::optional<internal_type>(str);
  }
};

/*  Specialization for translator_between missing -- generated by CMake for each of CAEN's enum definitions  */

#endif
