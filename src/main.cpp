/**
 * Parse the UTF8 ".ini" file via the Boost property_tree
 */

#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>   // std::hex
#include <stdexcept> // exceptions

// BOOST
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include <boost/program_options.hpp>
#include <boost/optional.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/foreach.hpp>
// BOOST logging
#include <boost/log/expressions.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/sources/severity_channel_logger.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>

#include <CaenEnum2Str.hpp> // generated by CMake in build directory


// Define the attribute keywords
BOOST_LOG_ATTRIBUTE_KEYWORD(line_id, "LineID", unsigned int)
BOOST_LOG_ATTRIBUTE_KEYWORD(severity, "Severity", boost::log::trivial::severity_level)
BOOST_LOG_ATTRIBUTE_KEYWORD(channel, "Channel", std::string)

boost::log::sources::severity_channel_logger< boost::log::trivial::severity_level, std::string > lg;

#define MAIN_LOG_DEBUG                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "main", boost::log::trivial::debug)
#define MAIN_LOG_INFO                                           \
  BOOST_LOG_CHANNEL_SEV(lg, "main", boost::log::trivial::info)
#define MAIN_LOG_WARN                                             \
  BOOST_LOG_CHANNEL_SEV(lg, "main", boost::log::trivial::warning)
#define MAIN_LOG_ERROR                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "main", boost::log::trivial::error)
#define MAIN_LOG_FATAL                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "main", boost::log::trivial::fatal)

#define CFG_LOG_DEBUG                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::debug)
#define CFG_LOG_INFO                                           \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::info)
#define CFG_LOG_WARN                                             \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::warning)
#define CFG_LOG_ERROR                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::error)
#define CFG_LOG_FATAL                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::fatal)


/* namespace alias */
namespace po = boost::program_options;
namespace pt = boost::property_tree;

namespace cadidaq {
  class settings;
  class digitizerSettings;
  class connectionSettings;
}

class cadidaq::settings {
public:
  settings(std::string name) :
    name(name)
  {}
  ~settings(){;}
  void parse(pt::iptree *node){processPTree(node, parseDirection::READING);}
  pt::iptree* createPTree(){pt::iptree *node = new pt::iptree(); processPTree(node, parseDirection::WRITING); return node;}
  virtual void verify(){};
  void print(){
    // convert all settings to a PTree
    pt::iptree *node = createPTree();
    std::cout << " Config for '" << name << "'" << std::endl;
    /* Loop over all sub sections and keys */
    for (auto& key : *node){
      std::cout << "\t" << key.first << " = " << key.second.get_value<std::string>() << std::endl;
    }
    delete node;
  };
  std::string getName(){return name;}
protected:
  std::string name;
  enum class parseDirection {READING, WRITING};
  template <class CAEN_ENUM> boost::optional<CAEN_ENUM> iFindStringInBimap(boost::bimap< std::string, CAEN_ENUM > map, std::string str);
  template <class VALUE> void parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, parseDirection direction);
  template <class VALUE> void parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, parseDirection direction, int base);
  template <class CAEN_ENUM, typename VALUE> void parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, boost::bimap< std::string, CAEN_ENUM > map, parseDirection direction);
private:
  virtual void processPTree(pt::iptree *node, parseDirection direction){};
};

class cadidaq::connectionSettings : public settings {
public:
  connectionSettings(std::string name) : cadidaq::settings(name) {}
  ~connectionSettings(){;}

  void verify();

  boost::optional<int>      linkType;
  boost::optional<int>      linkNum;
  boost::optional<int>      conetNode;
  boost::optional<uint32_t> vmeBaseAddress;
private:
  virtual void processPTree(pt::iptree *node, parseDirection direction);
};


template <class CAEN_ENUM> boost::optional<CAEN_ENUM> cadidaq::settings::iFindStringInBimap(boost::bimap< std::string, CAEN_ENUM > map, std::string str){
  typedef typename boost::bimap< std::string, CAEN_ENUM >::left_const_iterator const_iterator;
  for( const_iterator i = map.left.begin(), iend = map.left.end(); i != iend; ++i ){
      if(boost::iequals(boost::algorithm::to_lower_copy(i->first), str))
        return i->second;
    }
  return boost::none;
}


template <class VALUE> void cadidaq::settings::parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, parseDirection direction){
  if (direction == parseDirection::READING){
    // get the setting's value from the ptree
    settingValue = node->get_optional<VALUE>(settingName);
    if (settingValue) {
      CFG_LOG_DEBUG << "found key " << settingName << " with value '" << *settingValue << "'" << std::endl;
    } else {
      CFG_LOG_DEBUG << "could not find key '" << settingName << "'" << std::endl;
    }
    // erase value from ptree as it has been successfully parsed
    // NOTE: this will only erase a single instance of the key; if the key exists several times, the other entries remain!
    node->erase(settingName);
  } else {
    // direction: WRITING
    // add key to ptree if the setting's value has been set
    if (settingValue) {
      node->put(settingName, *settingValue);
    } else {
      CFG_LOG_WARN << "missing key '" << settingName << "' when generating config ptree " << std::endl;
    }
  }
}

template <class VALUE> void cadidaq::settings::parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, parseDirection direction, int base){
  if (direction == parseDirection::READING){
    // get the setting's value from the ptree
    boost::optional<std::string> str;
    parseSetting(settingName, node, str, direction);
    if (str) {
      // verify that we are dealing with a hex (0xXXXX) string
      if (str->size()>2)
        if(str->substr(0,2) != "0x" && base == 16){
          base = 10; // reset to base 10
          CFG_LOG_WARN << " key '" << settingName << "' with string value '" << *str << "' does not appear to be a hex value, handling as base 10 instead." << std::endl;
        }
      settingValue = std::stoul(*str, nullptr, base); // TODO: handle exceptions and remaining, unconverted characters
      CFG_LOG_DEBUG << " key '" << settingName << "' with string value '" << *str << "' converted to value " << *settingValue << std::endl;
    } else {
      settingValue = boost::none;
    }
  } else {
    // direction: WRITING
    if (!settingValue) return; // check that setting's value is set
    // now convert value to string based on given base
    boost::optional<std::string> strvalue;
    if (base==10){
      strvalue = std::to_string(*settingValue);
    } else if (base==16){
      std::stringstream ss;
      ss << std::hex << std::showbase << settingValue; // might need e.g. std::setfill ('0') and std::setw(sizeof(your_type)*2)
      strvalue = ss.str();
    } else {
      // base not yet implemented:
      throw std::out_of_range (std::string("Base value not implemented in parseSetting: ") + std::to_string(base));
    }
    // add key to ptree
    parseSetting(settingName, node, strvalue, direction);
  }
}

template <class CAEN_ENUM, typename VALUE> void cadidaq::settings::parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, boost::bimap< std::string, CAEN_ENUM > map, parseDirection direction){
  if (direction == parseDirection::READING){
    boost::optional<std::string> str;
    // get the setting's value from the ptree and append
    parseSetting(settingName, node, str, direction);
    if (str){
      settingValue = iFindStringInBimap(map, std::string("CAEN_DGTZ_") + *str); // match the enum nanming convention in CAEN's driver

      CFG_LOG_DEBUG << " value of key " << settingName << " with value '" << *str << "' converted to value " << *settingValue << " (" << map.right.at(static_cast<CAEN_ENUM>(*settingValue)) << ")" << std::endl;
    } else {
      settingValue = boost::none;
    }
  } else {
    // direction: WRITING

    // check that setting's value (boost::optional) is actually set
    if (!settingValue) return;
    // find the string corresponding to the setting's enum value in the bimap
    boost::optional<std::string> strvalue = map.right.at(static_cast<CAEN_ENUM>(*settingValue));
    // remove the first part originating from CAEN's enum naming convention ("CAEN_DGTZ_")
    strvalue->erase(0,10);
    // add key to ptree
    parseSetting(settingName, node, strvalue, direction);
  }
}


void cadidaq::connectionSettings::verify(){

  if (!linkType){
    std::cout << "Missing (or invalid) non-optional setting 'LinkType' in section '" << name << "'" << std::endl;
    throw std::invalid_argument(std::string("Missing (or invalid) setting for 'LinkType'"));
  }
  if (*linkType == CAEN_DGTZ_USB){
    if (conetNode && *conetNode != 0)
      std::cout << "When using LinkType=USB, set ConetNode to '0'! Fixed." << std::endl;
    conetNode = 0;
  }

}

void cadidaq::connectionSettings::processPTree(pt::iptree *node, parseDirection direction){
    // this routine implements the calls to ParseSetting for individual settings read from config or stored internally
    std::cout << "Parsing ptree for configuration of '" << name << "'" << std::endl;
    /* Loop over all sub sections and keys */
    for (auto& key : *node){
      std::cout << "\t" << key.first << " = " << key.second.get_value<std::string>() << std::endl;
    }

    cadidaq::CaenEnum2str converter;

    parseSetting("LinkType", node, linkType, converter.bm_CAEN_DGTZ_ConnectionType, direction);
    parseSetting("LinkNum", node, linkNum, direction);
    parseSetting("ConetNode", node, conetNode, direction);
    parseSetting("VMEBaseAddress", node, vmeBaseAddress, direction, 16);

    // TODO: this should probably be warnings when reading and debug info when writing
    std::cout << std::endl << "ptree after parsing (remaining entries are unparsed): " << std::endl;
    /* Loop over all sub sections and keys */
    for (auto& key : *node){
      std::cout << "\t" << key.first << " = " << key.second.get_value<std::string>() << std::endl;
    }
  }


void read_ini_file(const char *filename)
{

    /* Open the UTF8 .ini file */
    std::ifstream iniStream(filename);

    /* Parse the .ini file via boost::property_tree::ini_parser */
    pt::iptree iniPTree; // ptree w/ case-insensitive comparisons
    pt::ini_parser::read_ini(iniStream, iniPTree);

    printf("\n\nFull config:\n");
    /* Loop over all sections and keys */
    for (auto& section : iniPTree){
      std::cout << '[' << section.first << "]" << std::endl;
      for (auto& key : section.second)
        std::cout << key.first << "=" << key.second.get_value<std::string>() << std::endl;
    }

    // parse the config file to determine number of digitizers
    int NDigitizer = 0;
    for (auto& section : iniPTree){
      if(boost::iequals(boost::algorithm::to_lower_copy(section.first), std::string("daq")))
        continue;
      if(boost::iequals(boost::algorithm::to_lower_copy(section.first), std::string("general")))
        continue;
      NDigitizer++;
    }
    std::cout << "Configuration for " << NDigitizer << " digitizer(s) found in config file." << std::endl;

    std::vector<cadidaq::connectionSettings*> vecSettings;
    // get the connection details for each digitizer section
    for (auto& section : iniPTree){
      if(boost::iequals(boost::algorithm::to_lower_copy(section.first), std::string("daq")))
        continue;
      if(boost::iequals(boost::algorithm::to_lower_copy(section.first), std::string("general")))
        continue;
      pt::iptree &node = iniPTree.get_child(section.first);
      cadidaq::connectionSettings* settings = new cadidaq::connectionSettings(section.first);
      settings->parse(&node);
      settings->verify();
      vecSettings.push_back(settings);
    }

    // write the config back to another file
    pt::iptree ptwrite; // create a new tree
    BOOST_FOREACH(cadidaq::connectionSettings *settings, vecSettings){
      pt::iptree *node = settings->createPTree();
      ptwrite.put_child(settings->getName(), *node);
    }
    pt::ini_parser::write_ini("output.ini", ptwrite);
}

int main(int argc, char **argv)
{
    po::options_description desc("MainOptions");
    desc.add_options()
        ("help,h", "Print help message")
        ("file,f", 
            po::value<std::string>()->default_value("test.ini"),
            "The test .ini file");

    po::variables_map vm;
    try
    {
        po::store(po::parse_command_line(argc, argv, desc), vm);
    }
    catch (po::error &e)
    {
        /* Invalid options */
        std::cerr << "ERROR: " << e.what() << std::endl << std::endl;
        std::cout << "Boost property_tree tester:" << std::endl
            << desc << std::endl;
        return 0;
    }

    if (vm.count("help"))
    {
        /* print usage */
        std::cout << "Boost property_tree tester:" << std::endl
                  << desc << std::endl;
        return 0;
    }

    // init BOOST logging
    // Create a minimal severity table filter
    typedef boost::log::expressions::channel_severity_filter_actor< std::string, boost::log::trivial::severity_level > min_severity_filter;
    min_severity_filter min_severity = boost::log::expressions::channel_severity_filter(channel, severity);
  
    // Set up the minimum severity levels for different channels
    min_severity["cfg"] = boost::log::trivial::debug;
    min_severity["main"] = boost::log::trivial::info;
  
    boost::log::add_console_log(
                                std::clog,
                                boost::log::keywords::filter = min_severity || severity >= boost::log::trivial::fatal,
                                boost::log::keywords::format =
                                (
                                 boost::log::expressions::stream
                                 << line_id
                                 << ": <" << severity
                                 << "> [" << channel << "] "
                                 << boost::log::expressions::smessage
                                 )
                                );
    boost::log::add_common_attributes();


    std::string iniFile = vm["file"].as<std::string>().c_str();
    std::cout << "Read ini file: " << iniFile << std::endl;
    read_ini_file(iniFile.c_str());
    return 0;
}

